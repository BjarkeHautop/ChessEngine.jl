var documenterSearchIndex = {"docs":
[{"location":"40-benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"40-benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Starting from version 0.2.0 of OrbisChessEngine this page shows benchmark results for perft for various depths. Can be used to compare performance with older versions.","category":"page"},{"location":"40-benchmarks/#Benchmark-Results-for-Perft","page":"Benchmarks","title":"Benchmark Results for Perft","text":"","category":"section"},{"location":"40-benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"All benchmarks below are using a single thread. Perft uses the Board stuct from OrbisChessEngine, which means it computes zobrist hash, and evaluation score at each node. Thus, it mimics the search process more closely than a pure move generator perft.","category":"page"},{"location":"40-benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using OrbisChessEngine\nusing BenchmarkTools\nb = Board()\nperft(b, 5) # warm up\n@benchmark perft($b, 5)","category":"page"},{"location":"40-benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Using perft_bishop_magic which uses magic bitboards for bishop move generation:","category":"page"},{"location":"40-benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using OrbisChessEngine\nusing BenchmarkTools\nb = Board()\nperft_bishop_magic(b, 5) # warm up\n@benchmark perft_bishop_magic($b, 5)","category":"page"},{"location":"40-benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Seems to be barely affect performance.","category":"page"},{"location":"40-benchmarks/#Benchmark-Results-for-Search","page":"Benchmarks","title":"Benchmark Results for Search","text":"","category":"section"},{"location":"40-benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Benchmarking search to depth 10 from starting position:","category":"page"},{"location":"40-benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using OrbisChessEngine\nusing BenchmarkTools\nb = Board()\nsearch(b; depth = 4) # warm up\n@benchmark search($b; depth = 10, opening_book = nothing)","category":"page"},{"location":"95-reference/#reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"95-reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#OrbisChessEngine.Board","page":"Reference","title":"OrbisChessEngine.Board","text":"Board\n\nA chess board representation using bitboards.\n\nbitboards: A fixed-size vector where each element corresponds to a piece type's bitboard.\nside_to_move: The side to move.\ncastling_rights: A 4-bit integer representing castling rights (KQkq).\nen_passant: The square index (0-63) for en passant target, or -1 if none.\nhalfmove_clock: The number of halfmoves since the last capture or pawn move (for the 50-move rule).\nposition_history: A vector of position Zobrist hashes for detecting threefold repetition.\nundo_stack: A stack of UndoInfo structs for unmaking moves.\nundo_index: The current index in the undo stack.\neval_score: Cached evaluation score from White's point of view.\ngame_phase_value: Cached phase numerator (sum of weights) for evaluation scaling.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#OrbisChessEngine.Game","page":"Reference","title":"OrbisChessEngine.Game","text":"Game\n\nA struct representing a chess game with time control.\n\nboard: The current state of the chess board.\nwhite_time: Time remaining for White in milliseconds.\nblack_time: Time remaining for Black in milliseconds.\nincrement: Time increment per move in milliseconds.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#OrbisChessEngine.Move","page":"Reference","title":"OrbisChessEngine.Move","text":"Move\n\nA chess move.\n\nfrom is a square index (0-63)\nto is a square index (0-63)\npromotion is the piece type promoted to (0 if none)\ncapture is captured piece type (0 if none)\ncastling: 0 = normal, 1 = kingside, 2 = queenside\nen_passant: true if en passant capture\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#OrbisChessEngine.Move-Tuple{Board, AbstractString}","page":"Reference","title":"OrbisChessEngine.Move","text":"Move(board::Board, str::AbstractString)\n\nConstruct a Move from a long algebraic string like \"e2e4\" or \"e7e8=Q\", using the board to infer capture, en passant, and castling.\n\nboard: current Board state\nstr: move string in long algebraic notation\n\nCaptures are inferred based on the board state (so \"e4d5\" captures if d5 is occupied by opponent). Castling can be specified with \"O-O\" (kingside) or \"O-O-O\" (queenside). Also accepts \"o-o\", \"0-0\", \"o-o-o\", \"0-0-0\".\n\nNote, that this function does not validate the legality of the move; it only constructs the Move object.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#OrbisChessEngine.SearchResult","page":"Reference","title":"OrbisChessEngine.SearchResult","text":"SearchResult\n\nResult of a search operation.\n\nscore: The evaluation score of the position.\nmove: The best move found.\nfrom_book: Boolean indicating if the move was from the opening book.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#OrbisChessEngine.UndoInfo","page":"Reference","title":"OrbisChessEngine.UndoInfo","text":"UndoInfo\n\nInformation needed to undo a move\n\ncaptured_piece: The piece type that was captured, or 0 if none.\nen_passant: The previous en passant square.\ncastling_rights: The previous castling rights.\nhalfmove_clock: The previous halfmove clock.\nmoved_piece: The piece type that was moved.\npromotion: The piece type if the move was a promotion, or 0 otherwise.\nis_en_passant: A boolean indicating if the move was an en passant capture.\nprev_eval_score: The evaluation score before the move.\nprev_game_phase_value: The game phase value before the move.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#OrbisChessEngine.evaluate-Tuple{Board}","page":"Reference","title":"OrbisChessEngine.evaluate","text":"evaluate(board::Board) -> Int\n\nEvaluate a position from White’s perspective using piece-square tables.\n\nboard: Board struct\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#OrbisChessEngine.game_status-Tuple{Board}","page":"Reference","title":"OrbisChessEngine.game_status","text":"game_status(board::Board) -> Symbol\n\nReturn the current game status (checkmate, stalemate, draw, timeout, or ongoing).\n\ngame: Game struct\n\nReturns: Symbol — one of\n\n:checkmate_white\n:checkmate_black\n:stalemate\n:draw_threefold\n:draw_fiftymove\n:draw_insufficient_material\n:timeout_white\n:timeout_black\n:ongoing\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#OrbisChessEngine.game_status-Tuple{Game}","page":"Reference","title":"OrbisChessEngine.game_status","text":"game_status(game::Game) -> Symbol\n\nReturn the current game status (checkmate, stalemate, draw, timeout, or ongoing).\n\ngame: Game struct\n\nReturns: Symbol — one of\n\n:checkmate_white\n:checkmate_black\n:stalemate\n:draw_threefold\n:draw_fiftymove\n:draw_insufficient_material\n:timeout_white\n:timeout_black\n:ongoing\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#OrbisChessEngine.in_check-Tuple{Board, OrbisChessEngine.Side}","page":"Reference","title":"OrbisChessEngine.in_check","text":"in_check(board::Board, side::Side) -> Bool\n\nCheck if the king of the given side is in check\n\nboard: Board struct\nside: Side (WHITE or BLACK)\n\nReturns: Bool\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#OrbisChessEngine.load_polyglot_book-Tuple{String}","page":"Reference","title":"OrbisChessEngine.load_polyglot_book","text":"load_polyglot_book(path::String) -> PolyglotBook\n\nLoad a Polyglot opening book from the specified binary file. See for example free-opening-books for several free Polyglot book files.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#OrbisChessEngine.make_move!-Tuple{Board, Move}","page":"Reference","title":"OrbisChessEngine.make_move!","text":"make_move!(board, m)\n\nApply move m to board, modifying it in place.\n\nboard: Board struct\nm: Move\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#OrbisChessEngine.make_move-Tuple{Board, Move}","page":"Reference","title":"OrbisChessEngine.make_move","text":"make_move(board, m) -> Board\n\nReturn a new board with move m applied, leaving the original board unchanged.\n\nboard: Board struct\nm: Move\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#OrbisChessEngine.make_timed_move!-Tuple{Game}","page":"Reference","title":"OrbisChessEngine.make_timed_move!","text":"make_timed_move!(game::Game; opening_book::Union{Nothing, PolyglotBook}=KOMODO_OPENING_BOOK, verbose=false)\n\nSearches for and makes a move for the current player, updating the Game struct with the updated board and time remaining.\n\ngame: Game struct\nopening_book: Optional PolyglotBook for opening moves\nverbose: If true, print move details and time used\n\nThe time allocated for the search is done automatically based on remaining time and increment. See search for details on how the search is performed.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#OrbisChessEngine.make_timed_move-Tuple{Game}","page":"Reference","title":"OrbisChessEngine.make_timed_move","text":"make_timed_move(game::Game; opening_book::Union{Nothing, PolyglotBook}=KOMODO_OPENING_BOOK, verbose=false) -> Game\n\nSearches for and makes a move for the current player, returning a new Game struct with the updated board and time remaining.\n\ngame: Game struct\nopening_book: Optional PolyglotBook for opening moves\nverbose: If true, print move details and time used\n\nThe time allocated for the search is done automatically based on remaining time and increment. See search for details on how the search is performed.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#OrbisChessEngine.perft-Tuple{Board, Int64}","page":"Reference","title":"OrbisChessEngine.perft","text":"perft(board::Board, depth::Int) -> Int\n\nCompute the number of leaf nodes reachable from the given board position at the given depth. It uses the Board struct to immitate search behavior. In particular, this means it still computes zobrist hashes and updates evaluation scores slowing it down compared to a minimal perft implementation.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#OrbisChessEngine.perft_fast-Tuple{Board, Int64}","page":"Reference","title":"OrbisChessEngine.perft_fast","text":"perft_fast(board::Board, depth::Int) -> Int\n\nCompute the number of leaf nodes reachable from the given board position at the given depth using multiple threads at the root. It uses the Board struct to immitate search behavior. In particular, this means it still computes zobrist hashes and updates evaluation scores slowing it down compared to a minimal perft implementation.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#OrbisChessEngine.plot_board-Tuple{Board}","page":"Reference","title":"OrbisChessEngine.plot_board","text":"plot_board(board::Board) -> Makie.Figure\n\nPlot the chess board and pieces using Makie.jl\n\nboard: Board struct\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#OrbisChessEngine.plot_board-Tuple{Game}","page":"Reference","title":"OrbisChessEngine.plot_board","text":"plot_board(game::Game) -> Makie.Figure\n\nPlot the chess board and pieces using Makie.jl\n\ngame: Game struct\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#OrbisChessEngine.search-Tuple{Board}","page":"Reference","title":"OrbisChessEngine.search","text":"search(\n    board::Board;\n    depth::Int,\n    opening_book::Union{Nothing, PolyglotBook} = KOMODO_OPENING_BOOK,\n    verbose::Bool = false,\n    time_budget::Int = typemax(Int)\n)::SearchResult\n\nSearch for the best move using minimax with iterative deepening, alpha-beta pruning, quiescence search, null move pruning, and transposition tables.\n\nArguments:\n\nboard: current board position\ndepth: search depth\nopening_book: if provided, uses a opening book. Default is KOMODO_OPENING_BOOK\n\ntaken from free-opening-books. Set to nothing to disable. See load_polyglot_book to load custom books.\n\nverbose: if true, prints search information and principal variation (PV) at each depth\ntime_budget: time in milliseconds to stop the search (if depth not reached)\n\nReturns:\n\nSearchResult containing the best move and its evaluation score (or nothing if no move found)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#OrbisChessEngine.undo_move!-Tuple{Board, Move}","page":"Reference","title":"OrbisChessEngine.undo_move!","text":"undo_move!(board::Board, m::Move)\n\nUndo move m on board in place, restoring previous state.\n\nboard: Board struct\nm: Move struct\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#OrbisChessEngine.undo_move-Tuple{Board, Move}","page":"Reference","title":"OrbisChessEngine.undo_move","text":"undo_move(board::Board, m::Move) -> Board\n\nReturn a new board with move m undone, leaving the original board unchanged.\n\nboard: Board struct\nm: Move struct\n\n\n\n\n\n","category":"method"},{"location":"05-quick-guide/#quick_guide","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"05-quick-guide/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"The OrbisChessEngine package is available through the Julia package system by running Pkg.add(\"OrbisChessEngine\"). Throughout, we assume that you have installed the package.","category":"page"},{"location":"05-quick-guide/#Playing-Chess","page":"Getting Started","title":"Playing Chess","text":"","category":"section"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"First we load the package:","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"using OrbisChessEngine","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"We can create a starting position using:","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"board = Board()","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"or load a game from a FEN string:","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"board = Board(fen=\"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\")","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"This is a struct of type Board which contains the bitboards, side to move, castling rights, en passant square, halfmove clock, position history, undo stack, eval score and game phase value.","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"To view the board in a Plot panel we can use","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"plot_board(board)","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"We can use Move to create a move. Several formats are supported, but the simplest is","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"mv = Move(board, \"e2e4\")","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"The advantage of the move format used above, is that you don't have to specify captures, promotions or castling, as these are inferred from the board position (hence it needs the board as an argument).","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"We can make a move using by make_move or the in-place version make_move!:","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"make_move!(board, mv)","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"We can undo a move using undo_move or the in-place version undo_move!:","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"undo_move!(board, mv)","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"Note, that make_move allows for illegal moves. You can get all legal moves using generate_legal_moves:","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"legal_moves = generate_legal_moves(board)","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"You can check the game status using game_status:","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"game_status(board)","category":"page"},{"location":"05-quick-guide/#Using-the-Engine","page":"Getting Started","title":"Using the Engine","text":"","category":"section"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"To generate a move using the engine we can use search:","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"result = search(board; depth=3, opening_book=nothing)","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"search returns a SearchResult object containing the evaluation score, the move and if it is a book move. This package ships with a small opening book, which is default when calling search. To disable the opening book, set opening_book=nothing. To use a custom opening book use load_polyglot_book to load another polyglot book in .bin format.","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"To make a 3+2 game we can use Game:","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"game = Game(; minutes = 3, increment = 2)","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"or the short-hand notation:","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"game = Game(\"3+2\")","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"This is a struct of type Game which contains the board, white and black time left, and the increment.","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"The engine will then automatically allocate how much time to use for each move. To let the engine make a move in a timed game we can use make_timed_move!:","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"make_timed_move!(game)","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"Combining everything we can let the engine play against itself in a 1+1 game:","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"game = Game(\"1+1\")\nplots = []\nwhile game_status(game.board) == :ongoing\n    make_timed_move!(game)\n    push!(plots, display(game))\nend","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"And view the game:","category":"page"},{"location":"05-quick-guide/","page":"Getting Started","title":"Getting Started","text":"for i in eachindex(plots)\n    sleep(0.5)\n    display(plots[i])\nend","category":"page"},{"location":"98-internal-api/#Internal-API-Reference","page":"Internal API Reference","title":"Internal API Reference","text":"","category":"section"},{"location":"98-internal-api/#OrbisChessEngine.TTEntry","page":"Internal API Reference","title":"OrbisChessEngine.TTEntry","text":"Transposition table entry.\n\nkey: Zobrist hash of the position (for collision checking)\nvalue: evaluation score\ndepth: search depth at which this value was computed\nnode_type: type of node (EXACT, LOWERBOUND, UPPERBOUND)\nbest_move: best move found from this position\n\n\n\n\n\n","category":"type"},{"location":"98-internal-api/#Base.show-Tuple{IO, Board}","page":"Internal API Reference","title":"Base.show","text":"Base.show(io::IO, board::Board)\n\nDisplay a simple ASCII representation of the given Board in the terminal.\n\nEach square shows either a piece or a dot . for empty squares. Piece symbols:\n\nWhite: P (pawn), N (knight), B (bishop), R (rook), Q (queen), K (king)\nBlack: p (pawn), n (knight), b (bishop), r (rook), q (queen), k (king)\n\nThe board is printed with rank 8 at the top and file a on the left.\n\nExample\n\nb = Board() # prints the initial chess position\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#Base.show-Tuple{IO, Game}","page":"Internal API Reference","title":"Base.show","text":"Base.show(io::IO, game::Game)\n\nDisplay a simple ASCII representation of the given Board in the terminal.\n\nEach square shows either a piece or a dot . for empty squares. Piece symbols:\n\nWhite: P (pawn), N (knight), B (bishop), R (rook), Q (queen), K (king)\nBlack: p (pawn), n (knight), b (bishop), r (rook), q (queen), k (king)\n\nThe board is printed with rank 8 at the top and file a on the left.\n\nExample\n\ng = Game() # prints the initial chess position\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine._filter_legal_moves!-Tuple{Board, Vector{Move}, Int64, Int64, Vector{Move}, Int64}","page":"Internal API Reference","title":"OrbisChessEngine._filter_legal_moves!","text":"_filter_legal_moves!(board, pseudo, start, stop, moves, n_moves)\n\nFilters pseudo-legal moves into legal moves, avoiding full make/undo for moves that clearly cannot expose the king.\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.clearbit-Tuple{Any, Any}","page":"Internal API Reference","title":"OrbisChessEngine.clearbit","text":"Clear bit at square sq.\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.compute_eval_and_phase-Tuple{Board}","page":"Internal API Reference","title":"OrbisChessEngine.compute_eval_and_phase","text":"compute_eval_and_phase(board::Board) -> (Int, Int)\n\nCompute the evaluation score (from White's perspective) and the game phase value from scratch for a given board.\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.count_bits-Tuple{UInt64}","page":"Internal API Reference","title":"OrbisChessEngine.count_bits","text":"Count the number of bits set in a UInt64.\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.extract_pv-Tuple{Board, Int64}","page":"Internal API Reference","title":"OrbisChessEngine.extract_pv","text":"Reconstruct the principal variation (PV) from the transposition table\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.file_rank-Tuple{Any}","page":"Internal API Reference","title":"OrbisChessEngine.file_rank","text":"file_rank(sq) -> (Int, Int)\n\nReturn file (1..8) and rank (1..8) for a square index\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.find_magic-Tuple{Any, Any, Any}","page":"Internal API Reference","title":"OrbisChessEngine.find_magic","text":"Try to find a magic number for a given square.\n\nsq: square index 0–63\nmasks: precomputed mask table (bishop or rook)\nattack_fn: function (sq, occ) → attacks\ntries: number of random candidates to attempt\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.flip_table-Tuple{Any}","page":"Internal API Reference","title":"OrbisChessEngine.flip_table","text":"Flip a piece-square table vertically (white → black perspective). Input is a 64-element vector (row-major, starting at A8). Returns a new 64-element vector with ranks mirrored.\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.generate_magics-Tuple{Any, Any}","page":"Internal API Reference","title":"OrbisChessEngine.generate_magics","text":"Compute magic numbers for all squares.\n\nmasks: precomputed mask table (bishop or rook)\nattack_fn: function (sq, occ) → attacks\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.generate_pawn_moves!-Tuple{Board, Vector{Move}, Int64}","page":"Internal API Reference","title":"OrbisChessEngine.generate_pawn_moves!","text":"Generate pseudo-legal pawn moves in-place\n\nboard: Board struct\nmoves: preallocated buffer to append moves\n\nReturns: number of moves added\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.generate_pawn_moves-Tuple{Board}","page":"Internal API Reference","title":"OrbisChessEngine.generate_pawn_moves","text":"Generate pseudo-legal pawn moves for the side to move\n\nboard: Board struct\n\nReturns: Vector of Move\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.is_fifty_move_rule-Tuple{Board}","page":"Internal API Reference","title":"OrbisChessEngine.is_fifty_move_rule","text":"Check for fifty-move rule\n\nboard: Board struct\n\nReturns: Bool\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.is_insufficient_material-Tuple{Board}","page":"Internal API Reference","title":"OrbisChessEngine.is_insufficient_material","text":"is_insufficient_material(board::Board) -> Bool\n\nCheck for insufficient material to mate\n\nboard: Board struct\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.is_threefold_repetition-Tuple{Board}","page":"Internal API Reference","title":"OrbisChessEngine.is_threefold_repetition","text":"Check for threefold repetition\n\nboard: Board struct\n\nReturns: Bool\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.king_square-Tuple{Board, OrbisChessEngine.Side}","page":"Internal API Reference","title":"OrbisChessEngine.king_square","text":"king_square(board::Board, side::Side) -> Int\n\nGet the square index of the king for the given side\n\nboard: Board struct\nside: Side (WHITE or BLACK)\n\nReturns: Int (square index 0..63)\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.make_null_move!-Tuple{Board}","page":"Internal API Reference","title":"OrbisChessEngine.make_null_move!","text":"Apply a null move (pass) to the board, modifying it in place. Used for null-move pruning.\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.move_ordering_score-Tuple{Board, Move, Int64}","page":"Internal API Reference","title":"OrbisChessEngine.move_ordering_score","text":"move_ordering_score(board::Board, m::Move, ply::Int)\n\nHeuristic to score moves for ordering:\n\nPromotions are prioritized highest.\nCaptures are prioritized higher.\nMoves giving check are prioritized.\nQuiet moves get a lower score.\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.next_square-Tuple{Int64, Tuple{Int64, Int64}}","page":"Internal API Reference","title":"OrbisChessEngine.next_square","text":"next_square(sq::Int, dir::Tuple{Int,Int}) -> Union{Int,Nothing}\n\nReturns the next square index in direction dir = (df, dr) from sq. Returns nothing if it goes off-board.\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.occupancy-Tuple{Board}","page":"Internal API Reference","title":"OrbisChessEngine.occupancy","text":"occupancy(board::Board) -> UInt64\n\nReturns a bitboard of all occupied squares.\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.occupancy_variations-Tuple{Any}","page":"Internal API Reference","title":"OrbisChessEngine.occupancy_variations","text":"Generate all possible occupancy bitboards for the given mask\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.piece_at-Tuple{Board, Any}","page":"Internal API Reference","title":"OrbisChessEngine.piece_at","text":"piece_at(board::Board, sq) -> Int\n\nReturn the piece type at a given square (0..63) using bitboards.\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.piece_from_symbol-Tuple{AbstractChar, OrbisChessEngine.Side}","page":"Internal API Reference","title":"OrbisChessEngine.piece_from_symbol","text":"piece_from_symbol(c::AbstractChar, side::Symbol)\n\nReturn the piece constant corresponding to promotion symbol c and the moving side (:white or :black).\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.piece_square_value-Tuple{Any, Any, Any}","page":"Internal API Reference","title":"OrbisChessEngine.piece_square_value","text":"Return the PSQT value of a piece on a given square.\n\npiece: Piece.WPAWN..Piece.BKING\nsquare: 0..63 (a1=0, h8=63)\nphase: Int (0..MAX_PHASE)\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.ray_between-Tuple{Any, Any, Any}","page":"Internal API Reference","title":"OrbisChessEngine.ray_between","text":"ray_between(board, king_sq::Int, from_sq::Int) -> Bool\n\nReturns true if moving a piece from from_sq could open a sliding attack (rook, bishop, queen) towards the king at king_sq.\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.setbit-Tuple{Any, Any}","page":"Internal API Reference","title":"OrbisChessEngine.setbit","text":"Set bit at square sq.\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.sliding_attack_from_occupancy-Tuple{Any, Any, Any}","page":"Internal API Reference","title":"OrbisChessEngine.sliding_attack_from_occupancy","text":"Generic sliding attack generator.\n\nsq: square index\nocc: occupancy bitboard\ndirections: list of (df, dr) directions\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.sliding_mask-Tuple{Any, Any}","page":"Internal API Reference","title":"OrbisChessEngine.sliding_mask","text":"Generic sliding mask generator.\n\nsq: square index (0..63)\ndirections: list of (df, dr) directions\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.square_attacked-Tuple{Board, Any, OrbisChessEngine.Side}","page":"Internal API Reference","title":"OrbisChessEngine.square_attacked","text":"square_attacked(board, sq, attacker) -> Bool\n\nCheck if a square is attacked by the given side.\n\nboard: Board struct\nsq: Int (square index 0..63)\nattacker: Side (WHITE or BLACK)\n\nReturns: Bool\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.square_index-Tuple{AbstractString}","page":"Internal API Reference","title":"OrbisChessEngine.square_index","text":"Map algebraic notation (e.g. 'e3') → square index (0..63).\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.square_index-Tuple{Any, Any}","page":"Internal API Reference","title":"OrbisChessEngine.square_index","text":"Map (file, rank) → square index (0..63). file=1→a, rank=1→1.\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.store_killer!-Tuple{Move, Int64}","page":"Internal API Reference","title":"OrbisChessEngine.store_killer!","text":"Store a killer move for the given ply. Only quiet moves (non-captures) are stored.\n\nm: the move to store\nply: the current ply\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.testbit-Tuple{Any, Any}","page":"Internal API Reference","title":"OrbisChessEngine.testbit","text":"Check if bit at square sq is set.\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.tt_index-Tuple{UInt64}","page":"Internal API Reference","title":"OrbisChessEngine.tt_index","text":"Get index in transposition table from hash.\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.tt_probe-Tuple{UInt64, Int64, Int64, Int64}","page":"Internal API Reference","title":"OrbisChessEngine.tt_probe","text":"Look up a position in the transposition table.\n\nhash: Zobrist hash of the position\ndepth: current search depth\nα: alpha value\nβ: beta value\n\nReturns a tuple (value, best_move, hit) where hit is true if a valid entry was found.\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.tt_store-Tuple{UInt64, Int64, Int64, OrbisChessEngine.NodeType, Move}","page":"Internal API Reference","title":"OrbisChessEngine.tt_store","text":"Store an entry in the transposition table.\n\n\n\n\n\n","category":"method"},{"location":"98-internal-api/#OrbisChessEngine.undo_null_move!-Tuple{Board}","page":"Internal API Reference","title":"OrbisChessEngine.undo_null_move!","text":"Undo a null move, restoring the previous board state.\n\n\n\n\n\n","category":"method"},{"location":"#OrbisChessEngine","page":"OrbisChessEngine","title":"OrbisChessEngine","text":"","category":"section"},{"location":"","page":"OrbisChessEngine","title":"OrbisChessEngine","text":"OrbisChessEngine is a chess engine written in Julia. It implements functionality for playing chess and for searching for the best move using the implemented chess engine.","category":"page"},{"location":"#Features","page":"OrbisChessEngine","title":"Features","text":"","category":"section"},{"location":"","page":"OrbisChessEngine","title":"OrbisChessEngine","text":"All chess rules\nBitboard representation\nLegal move generation (tested with perft)\nFEN parsing\nOpening book support\nMinimax search with alpha–beta pruning, iterative deepening, quiescence search, transposition tables, null move pruning, and move ordering heuristics\nEvaluation function based on piece-square tables","category":"page"},{"location":"#Getting-Started","page":"OrbisChessEngine","title":"Getting Started","text":"","category":"section"},{"location":"","page":"OrbisChessEngine","title":"OrbisChessEngine","text":"See the Getting Started page for installation instructions and basic usage examples.","category":"page"}]
}
