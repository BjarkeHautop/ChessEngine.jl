var documenterSearchIndex = {"docs":
[{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"Starting from version 0.2.0 of OrbisChessEngine this page shows benchmark results for perft for various depths. Can be used to compare performance with older versions.","category":"page"},{"location":"benchmarks/#Benchmark-Results","page":"Performance Benchmarks","title":"Benchmark Results","text":"","category":"section"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"All benchmarks below are using a single thread. Perft uses the Board stuct from OrbisChessEngine, which means it computes  zobrist hash, and evaluation score at each node. Thus, it mimics the search process more closely than a pure move generator perft.","category":"page"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"using OrbisChessEngine\nusing BenchmarkTools\nb = Board()\nperft(b, 5) # warm up\n@benchmark perft($b, 5)","category":"page"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"Using perft_bishop_magic which uses magic bitboards for bishop move generation:","category":"page"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"using OrbisChessEngine\nusing BenchmarkTools\nb = Board()\nperft_bishop_magic(b, 5) # warm up\n@benchmark perft_bishop_magic($b, 5)","category":"page"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"Seems to be barely affect performance.","category":"page"},{"location":"starting/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"starting/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"The OrbisChessEngine package is available through the Julia package system by running Pkg.add(\"OrbisChessEngine\"). Throughout, we assume that you have installed the package.","category":"page"},{"location":"starting/#Playing-Chess","page":"Getting Started","title":"Playing Chess","text":"","category":"section"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"First we load the package:","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"using OrbisChessEngine","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"We can create a starting position using:","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"board = Board()","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"or load a game from a FEN string:","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"board = Board(fen=\"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\")","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"This is a struct of type Board which contains the bitboards, side to move, castling rights, en passant square, halfmove clock, position history, undo stack, eval score and game phase value.","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"To display the board, we can use display:","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"display(board)","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"We can use Move to create a move. Several formats are supported, but the simplest is","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"mv = Move(board, \"e2e4\")","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"The advantage of the move format used above, is that you don't have to specify captures, promotions or castling, as these are inferred from the board position (hence it needs the board as an argument).","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"We can make a move using by make_move or the in-place version make_move!:","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"make_move!(board, mv)","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"We can undo a move using undo_move or the in-place version undo_move!:","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"undo_move!(board, mv)","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"Note, that make_move allows for illegal moves. You can get all legal moves using generate_legal_moves:","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"legal_moves = generate_legal_moves(board)","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"You can check the game status using game_status:","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"game_status(board)","category":"page"},{"location":"starting/#Using-the-Engine","page":"Getting Started","title":"Using the Engine","text":"","category":"section"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"To generate a move using the engine we can use search:","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"result = search(board; depth=3, opening_book=nothing)","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"search returns a SearchResult object containing the evaluation score, the move and if it is a book move. This package ships with a small opening book, which is default when calling search. To disable the opening book, set opening_book=nothing. To use a custom opening book use load_polyglot_book to load another polyglot book in .bin format.","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"To make a 3+2 game we can use Game:","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"game = Game(; minutes = 3, increment = 2)","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"or the short-hand notation:","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"game = Game(\"3+2\")","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"This is a struct of type Game which contains the board, white and black time left, and the increment.","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"The engine will then automatically allocate how much time to use for each move. To let the engine make a move in a timed game we can use make_timed_move!:","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"make_timed_move!(game)","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"Combining everything we can let the engine play against itself in a 1+1 game:","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"game = Game(\"1+1\")\nplots = []\nwhile game_status(game.board) == :ongoing\n    make_timed_move!(game)\n    push!(plots, display(game))\nend","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"And view the game:","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"for i in eachindex(plots)\n    sleep(0.5)\n    display(plots[i])\nend","category":"page"},{"location":"reference/#Public-API-Reference","page":"Reference","title":"Public API Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#OrbisChessEngine.Board","page":"Reference","title":"OrbisChessEngine.Board","text":"Board\n\nA chess board representation using bitboards.\n\nbitboards: A fixed-size vector where each element corresponds to a piece type's bitboard.\nside_to_move: The side to move.\ncastling_rights: A 4-bit integer representing castling rights (KQkq).\nen_passant: The square index (0-63) for en passant target, or -1 if none.\nhalfmove_clock: The number of halfmoves since the last capture or pawn move (for the 50-move rule).\nposition_history: A vector of position Zobrist hashes for detecting threefold repetition.\nundo_stack: A stack of UndoInfo structs for unmaking moves.\nundo_index: The current index in the undo stack.\neval_score: Cached evaluation score from White's point of view.\ngame_phase_value: Cached phase numerator (sum of weights) for evaluation scaling.\n\n\n\n\n\n","category":"type"},{"location":"reference/#OrbisChessEngine.Game","page":"Reference","title":"OrbisChessEngine.Game","text":"Game\n\nA struct representing a chess game with time control.\n\nboard: The current state of the chess board.\nwhite_time: Time remaining for White in milliseconds.\nblack_time: Time remaining for Black in milliseconds.\nincrement: Time increment per move in milliseconds.\n\n\n\n\n\n","category":"type"},{"location":"reference/#OrbisChessEngine.Move","page":"Reference","title":"OrbisChessEngine.Move","text":"Move\n\nA chess move.\n\nfrom is a square index (0-63)\nto is a square index (0-63)\npromotion is the piece type promoted to (0 if none)\ncapture is captured piece type (0 if none)\ncastling: 0 = normal, 1 = kingside, 2 = queenside\nen_passant: true if en passant capture\n\n\n\n\n\n","category":"type"},{"location":"reference/#OrbisChessEngine.Move-Tuple{Board, AbstractString}","page":"Reference","title":"OrbisChessEngine.Move","text":"Move(board::Board, str::AbstractString)\n\nConstruct a Move from a long algebraic string like \"e2e4\" or \"e7e8=Q\",  using the board to infer capture, en passant, and castling.\n\nboard: current Board state\nstr: move string in long algebraic notation\n\nCaptures are inferred based on the board state (so \"e4d5\" captures if d5 is occupied by opponent). Castling can be specified with \"O-O\" (kingside) or \"O-O-O\" (queenside).  Also accepts \"o-o\", \"0-0\", \"o-o-o\", \"0-0-0\".\n\nNote, that this function does not validate the legality of the move; it only constructs the Move object.\n\n\n\n\n\n","category":"method"},{"location":"reference/#OrbisChessEngine.SearchResult","page":"Reference","title":"OrbisChessEngine.SearchResult","text":"SearchResult\n\nResult of a search operation.\n\nscore: The evaluation score of the position.\nmove: The best move found.\nfrom_book: Boolean indicating if the move was from the opening book.\n\n\n\n\n\n","category":"type"},{"location":"reference/#OrbisChessEngine.UndoInfo","page":"Reference","title":"OrbisChessEngine.UndoInfo","text":"UndoInfo\n\nInformation needed to undo a move\n\ncaptured_piece: The piece type that was captured, or 0 if none.\nen_passant: The previous en passant square.\ncastling_rights: The previous castling rights.\nhalfmove_clock: The previous halfmove clock.\nmoved_piece: The piece type that was moved.\npromotion: The piece type if the move was a promotion, or 0 otherwise.\nis_en_passant: A boolean indicating if the move was an en passant capture.\nprev_eval_score: The evaluation score before the move.\nprev_game_phase_value: The game phase value before the move.\n\n\n\n\n\n","category":"type"},{"location":"reference/#OrbisChessEngine.evaluate-Tuple{Board}","page":"Reference","title":"OrbisChessEngine.evaluate","text":"evaluate(board::Board) -> Int\n\nEvaluate a position from White’s perspective using piece-square tables.\n\nboard: Board struct\n\n\n\n\n\n","category":"method"},{"location":"reference/#OrbisChessEngine.game_status-Tuple{Board}","page":"Reference","title":"OrbisChessEngine.game_status","text":"game_status(board::Board) -> Symbol\n\nReturn the current game status (checkmate, stalemate, draw, or ongoing)\n\nboard: Board struct\n\nReturns: Symbol - one of \n\n:checkmate_white  \n:checkmate_black  \n:stalemate  \n:draw_threefold  \n:draw_fiftymove  \n:draw_insufficient_material  \n:ongoing\n\n\n\n\n\n","category":"method"},{"location":"reference/#OrbisChessEngine.game_status-Tuple{Game}","page":"Reference","title":"OrbisChessEngine.game_status","text":"game_status(game::Game)\n\nReturn the current game status (checkmate, stalemate, draw, timeout, or ongoing).\n\ngame: Game struct  \n\nReturns: Symbol — one of  \n\n:checkmate_white  \n:checkmate_black  \n:stalemate  \n:draw_threefold  \n:draw_fiftymove  \n:draw_insufficient_material  \n:timeout_white  \n:timeout_black  \n:ongoing\n\n\n\n\n\n","category":"method"},{"location":"reference/#OrbisChessEngine.in_check-Tuple{Board, OrbisChessEngine.Side}","page":"Reference","title":"OrbisChessEngine.in_check","text":"in_check(board::Board, side::Side) -> Bool\n\nCheck if the king of the given side is in check\n\nboard: Board struct\nside: Side (WHITE or BLACK)\n\nReturns: Bool\n\n\n\n\n\n","category":"method"},{"location":"reference/#OrbisChessEngine.make_move!-Tuple{Board, Move}","page":"Reference","title":"OrbisChessEngine.make_move!","text":"make_move!(board, m)\n\nApply move m to board, modifying it in place.\n\nboard: Board struct\nm: Move\n\n\n\n\n\n","category":"method"},{"location":"reference/#OrbisChessEngine.make_move-Tuple{Board, Move}","page":"Reference","title":"OrbisChessEngine.make_move","text":"make_move(board, m) -> Board\n\nReturn a new board with move m applied, leaving the original board unchanged.\n\nboard: Board struct\nm: Move\n\n\n\n\n\n","category":"method"},{"location":"reference/#OrbisChessEngine.make_timed_move!-Tuple{Game}","page":"Reference","title":"OrbisChessEngine.make_timed_move!","text":"make_timed_move!(game::Game; opening_book::Union{Nothing, PolyglotBook}=KOMODO_OPENING_BOOK, verbose=false)\n\nSearches for and makes a move for the current player, updating the Game struct with the updated board and time remaining.\n\ngame: Game struct\nopening_book: Optional PolyglotBook for opening moves\nverbose: If true, print move details and time used\n\nThe time allocated for the search is done automatically based on remaining time and increment. See search for details on how the search is performed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#OrbisChessEngine.make_timed_move-Tuple{Game}","page":"Reference","title":"OrbisChessEngine.make_timed_move","text":"make_timed_move(game::Game; opening_book::Union{Nothing, PolyglotBook}=KOMODO_OPENING_BOOK, verbose=false) -> Game\n\nSearches for and makes a move for the current player, returning a new Game struct with the updated board and time remaining.\n\ngame: Game struct\nopening_book: Optional PolyglotBook for opening moves\nverbose: If true, print move details and time used\n\nThe time allocated for the search is done automatically based on remaining time and increment. See search for details on how the search is performed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#OrbisChessEngine.perft-Tuple{Board, Int64}","page":"Reference","title":"OrbisChessEngine.perft","text":"perft(board::Board, depth::Int) -> Int\n\nCompute the number of leaf nodes reachable from the given board position at the given depth. It uses the Board struct to immitate search behavior. In particular, this means it still computes zobrist hashes and updates evaluation scores slowing it down compared to a minimal perft implementation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#OrbisChessEngine.perft_fast-Tuple{Board, Int64}","page":"Reference","title":"OrbisChessEngine.perft_fast","text":"perft_fast(board::Board, depth::Int) -> Int\n\nCompute the number of leaf nodes reachable from the given board position at the given depth using multiple threads at the root. It uses the Board struct to immitate search behavior. In particular, this means it still computes zobrist hashes and updates evaluation scores slowing it down compared to a minimal perft implementation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#OrbisChessEngine.search-Tuple{Board}","page":"Reference","title":"OrbisChessEngine.search","text":"search(\n    board::Board;\n    depth::Int,\n    opening_book::Union{Nothing, PolyglotBook} = KOMODO_OPENING_BOOK,\n    verbose::Bool = false,\n    time_budget::Int = typemax(Int)\n)::SearchResult\n\nSearch for the best move using minimax with iterative deepening, alpha-beta pruning, quiescence search, null move pruning, and transposition tables.\n\nArguments:\n\nboard: current board position\ndepth: search depth\nopening_book: if provided, uses a opening book. Default is KOMODO_OPENING_BOOK \n\ntaken from free-opening-books.  Set to nothing to disable. \n\nverbose: if true, prints search information and principal variation (PV) at each depth\ntime_budget: time in milliseconds to stop the search (if depth not reached)\n\nReturns:\n\nSearchResult containing the best move and its evaluation score (or nothing if no move found)\n\n\n\n\n\n","category":"method"},{"location":"reference/#OrbisChessEngine.undo_move!-Tuple{Board, Move}","page":"Reference","title":"OrbisChessEngine.undo_move!","text":"undo_move!(board::Board, m::Move)\n\nUndo move m on board in place, restoring previous state.\n\nboard: Board struct\nm: Move struct\n\n\n\n\n\n","category":"method"},{"location":"reference/#OrbisChessEngine.undo_move-Tuple{Board, Move}","page":"Reference","title":"OrbisChessEngine.undo_move","text":"undo_move(board::Board, m::Move) -> Board\n\nReturn a new board with move m undone, leaving the original board unchanged.\n\nboard: Board struct\nm: Move struct\n\n\n\n\n\n","category":"method"},{"location":"#OrbisChessEngine","page":"Home","title":"OrbisChessEngine","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OrbisChessEngine is a Julia chess engine. It implements functionality for playing chess and for searching for the best move using the implemented chess engine.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All chess rules\nBitboard representation\nLegal move generation (tested with perft)\nFEN parsing \nOpening book support\nMinimax search with alpha–beta pruning, iterative deepening, quiescence search, transposition tables, null move pruning, and move ordering heuristics\nEvaluation function based on piece-square tables","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the Getting Started page for installation instructions and basic usage examples.","category":"page"},{"location":"developers/#Internal-API-Reference","page":"Developers","title":"Internal API Reference","text":"","category":"section"},{"location":"developers/#OrbisChessEngine.TTEntry","page":"Developers","title":"OrbisChessEngine.TTEntry","text":"Transposition table entry.\n\nkey: Zobrist hash of the position (for collision checking)\nvalue: evaluation score\ndepth: search depth at which this value was computed\nnode_type: type of node (EXACT, LOWERBOUND, UPPERBOUND)\nbest_move: best move found from this position\n\n\n\n\n\n","category":"type"},{"location":"developers/#OrbisChessEngine._filter_legal_moves!-Tuple{Board, Vector{Move}, Int64, Int64, Vector{Move}, Int64}","page":"Developers","title":"OrbisChessEngine._filter_legal_moves!","text":"_filter_legal_moves!(board, pseudo, start, stop, moves, n_moves)\n\nFilters pseudo-legal moves into legal moves, avoiding full make/undo for moves that clearly cannot expose the king.\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.clearbit-Tuple{Any, Any}","page":"Developers","title":"OrbisChessEngine.clearbit","text":"Clear bit at square sq.\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.compute_eval_and_phase-Tuple{Board}","page":"Developers","title":"OrbisChessEngine.compute_eval_and_phase","text":"compute_eval_and_phase(board::Board) -> (Int, Int)\n\nCompute the evaluation score (from White's perspective) and the game phase value from scratch for a given board.\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.count_bits-Tuple{UInt64}","page":"Developers","title":"OrbisChessEngine.count_bits","text":"Count the number of bits set in a UInt64.\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.extract_pv-Tuple{Board, Int64}","page":"Developers","title":"OrbisChessEngine.extract_pv","text":"Reconstruct the principal variation (PV) from the transposition table\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.file_rank-Tuple{Any}","page":"Developers","title":"OrbisChessEngine.file_rank","text":"file_rank(sq) -> (Int, Int)\n\nReturn file (1..8) and rank (1..8) for a square index\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.find_magic-Tuple{Any, Any, Any}","page":"Developers","title":"OrbisChessEngine.find_magic","text":"Try to find a magic number for a given square.\n\nsq: square index 0–63\nmasks: precomputed mask table (bishop or rook)\nattack_fn: function (sq, occ) → attacks\ntries: number of random candidates to attempt\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.flip_table-Tuple{Any}","page":"Developers","title":"OrbisChessEngine.flip_table","text":"Flip a piece-square table vertically (white → black perspective). Input is a 64-element vector (row-major, starting at A8). Returns a new 64-element vector with ranks mirrored.\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.generate_magics-Tuple{Any, Any}","page":"Developers","title":"OrbisChessEngine.generate_magics","text":"Compute magic numbers for all squares.\n\nmasks: precomputed mask table (bishop or rook)\nattack_fn: function (sq, occ) → attacks\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.generate_pawn_moves!-Tuple{Board, Vector{Move}, Int64}","page":"Developers","title":"OrbisChessEngine.generate_pawn_moves!","text":"Generate pseudo-legal pawn moves in-place\n\nboard: Board struct\nmoves: preallocated buffer to append moves\n\nReturns: number of moves added\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.generate_pawn_moves-Tuple{Board}","page":"Developers","title":"OrbisChessEngine.generate_pawn_moves","text":"Generate pseudo-legal pawn moves for the side to move\n\nboard: Board struct\n\nReturns: Vector of Move\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.is_fifty_move_rule-Tuple{Board}","page":"Developers","title":"OrbisChessEngine.is_fifty_move_rule","text":"Check for fifty-move rule\n\nboard: Board struct\n\nReturns: Bool\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.is_insufficient_material-Tuple{Board}","page":"Developers","title":"OrbisChessEngine.is_insufficient_material","text":"is_insufficient_material(board::Board) -> Bool\n\nCheck for insufficient material to mate\n\nboard: Board struct\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.is_threefold_repetition-Tuple{Board}","page":"Developers","title":"OrbisChessEngine.is_threefold_repetition","text":"Check for threefold repetition\n\nboard: Board struct\n\nReturns: Bool\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.king_square-Tuple{Board, OrbisChessEngine.Side}","page":"Developers","title":"OrbisChessEngine.king_square","text":"king_square(board::Board, side::Side) -> Int\n\nGet the square index of the king for the given side\n\nboard: Board struct\nside: Side (WHITE or BLACK)\n\nReturns: Int (square index 0..63)\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.make_null_move!-Tuple{Board}","page":"Developers","title":"OrbisChessEngine.make_null_move!","text":"Apply a null move (pass) to the board, modifying it in place. Used for null-move pruning.\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.move_ordering_score-Tuple{Board, Move, Int64}","page":"Developers","title":"OrbisChessEngine.move_ordering_score","text":"move_ordering_score(board::Board, m::Move, ply::Int)\n\nHeuristic to score moves for ordering:\n\nPromotions are prioritized highest.\nCaptures are prioritized higher.\nMoves giving check are prioritized.\nQuiet moves get a lower score.\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.next_square-Tuple{Int64, Tuple{Int64, Int64}}","page":"Developers","title":"OrbisChessEngine.next_square","text":"next_square(sq::Int, dir::Tuple{Int,Int}) -> Union{Int,Nothing}\n\nReturns the next square index in direction dir = (df, dr) from sq. Returns nothing if it goes off-board.\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.occupancy-Tuple{Board}","page":"Developers","title":"OrbisChessEngine.occupancy","text":"occupancy(board::Board) -> UInt64\n\nReturns a bitboard of all occupied squares.\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.occupancy_variations-Tuple{Any}","page":"Developers","title":"OrbisChessEngine.occupancy_variations","text":"Generate all possible occupancy bitboards for the given mask\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.piece_at-Tuple{Board, Any}","page":"Developers","title":"OrbisChessEngine.piece_at","text":"piece_at(board::Board, sq) -> Int\n\nReturn the piece type at a given square (0..63) using bitboards.\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.piece_from_symbol-Tuple{AbstractChar, OrbisChessEngine.Side}","page":"Developers","title":"OrbisChessEngine.piece_from_symbol","text":"piece_from_symbol(c::AbstractChar, side::Symbol)\n\nReturn the piece constant corresponding to promotion symbol c and the moving side (:white or :black).\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.piece_square_value-Tuple{Any, Any, Any}","page":"Developers","title":"OrbisChessEngine.piece_square_value","text":"Return the PSQT value of a piece on a given square.\n\npiece: Piece.WPAWN..Piece.BKING\nsquare: 0..63 (a1=0, h8=63)\nphase: Int (0..MAX_PHASE)\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.ray_between-Tuple{Any, Any, Any}","page":"Developers","title":"OrbisChessEngine.ray_between","text":"ray_between(board, king_sq::Int, from_sq::Int) -> Bool\n\nReturns true if moving a piece from from_sq could open a sliding attack (rook, bishop, queen) towards the king at king_sq.\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.setbit-Tuple{Any, Any}","page":"Developers","title":"OrbisChessEngine.setbit","text":"Set bit at square sq.\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.sliding_attack_from_occupancy-Tuple{Any, Any, Any}","page":"Developers","title":"OrbisChessEngine.sliding_attack_from_occupancy","text":"Generic sliding attack generator.\n\nsq: square index\nocc: occupancy bitboard\ndirections: list of (df, dr) directions\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.sliding_mask-Tuple{Any, Any}","page":"Developers","title":"OrbisChessEngine.sliding_mask","text":"Generic sliding mask generator.\n\nsq: square index (0..63)\ndirections: list of (df, dr) directions\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.square_attacked-Tuple{Board, Any, OrbisChessEngine.Side}","page":"Developers","title":"OrbisChessEngine.square_attacked","text":"square_attacked(board, sq, attacker) -> Bool\n\nCheck if a square is attacked by the given side.\n\nboard: Board struct\nsq: Int (square index 0..63)\nattacker: Side (WHITE or BLACK)\n\nReturns: Bool\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.square_index-Tuple{AbstractString}","page":"Developers","title":"OrbisChessEngine.square_index","text":"Map algebraic notation (e.g. 'e3') → square index (0..63).\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.square_index-Tuple{Any, Any}","page":"Developers","title":"OrbisChessEngine.square_index","text":"Map (file, rank) → square index (0..63). file=1→a, rank=1→1.\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.store_killer!-Tuple{Move, Int64}","page":"Developers","title":"OrbisChessEngine.store_killer!","text":"Store a killer move for the given ply. Only quiet moves (non-captures) are stored.\n\nm: the move to store\nply: the current ply\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.testbit-Tuple{Any, Any}","page":"Developers","title":"OrbisChessEngine.testbit","text":"Check if bit at square sq is set.\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.tt_index-Tuple{UInt64}","page":"Developers","title":"OrbisChessEngine.tt_index","text":"Get index in transposition table from hash.\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.tt_probe-Tuple{UInt64, Int64, Int64, Int64}","page":"Developers","title":"OrbisChessEngine.tt_probe","text":"Look up a position in the transposition table.\n\nhash: Zobrist hash of the position\ndepth: current search depth\nα: alpha value\nβ: beta value\n\nReturns a tuple (value, best_move, hit) where hit is true if a valid entry was found.\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.tt_store-Tuple{UInt64, Int64, Int64, OrbisChessEngine.NodeType, Move}","page":"Developers","title":"OrbisChessEngine.tt_store","text":"Store an entry in the transposition table.\n\n\n\n\n\n","category":"method"},{"location":"developers/#OrbisChessEngine.undo_null_move!-Tuple{Board}","page":"Developers","title":"OrbisChessEngine.undo_null_move!","text":"Undo a null move, restoring the previous board state.\n\n\n\n\n\n","category":"method"}]
}
