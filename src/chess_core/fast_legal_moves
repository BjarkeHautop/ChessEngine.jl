function generate_legal_moves!(board::Board, moves::Vector{Move})
    empty!(moves)

    # fill moves with pseudo-legal
    generate_pawn_moves!(board, moves)
    generate_knight_moves!(board, moves)
    generate_bishop_moves!(board, moves)
    generate_rook_moves!(board, moves)
    generate_queen_moves!(board, moves)
    generate_king_moves!(board, moves)

    side = board.side_to_move
    opp = opposite(side)

    i = 1
    while i <= length(moves)
        m = moves[i]

        # castling legality (check current board before move)
        if m.castling != 0
            if in_check(board, side)
                deleteat!(moves, i); continue
            end
            path = if side == WHITE
                m.castling == 1 ? (5, 6) : (3, 2)
            else
                m.castling == 1 ? (61, 62) : (59, 58)
            end
            if any(sq -> square_attacked(board, sq, opp), path)
                deleteat!(moves, i); continue
            end
        end

        make_move!(board, m)
        if in_check(board, side)
            unmake_move!(board, m)
            deleteat!(moves, i); continue
        end
        unmake_move!(board, m)

        i += 1
    end

    return moves
end

"""
Generate pseudo-legal knight moves in-place
- `board`: Board struct
- `moves`: preallocated buffer to append moves
Returns: number of moves added
"""
function generate_knight_moves!(board::Board, moves::Vector{Move})
    len_before = length(moves)

    if board.side_to_move == WHITE
        knights = board.bitboards[W_KNIGHT]
        enemy_pieces = B_PAWN:B_KING
        friendly_pieces = W_PAWN:W_KING
    else
        knights = board.bitboards[B_KNIGHT]
        enemy_pieces = W_PAWN:W_KING
        friendly_pieces = B_PAWN:B_KING
    end

    # Build bitboard of all friendly pieces
    occupied_friendly = zero(UInt64)
    for p in friendly_pieces
        occupied_friendly |= board.bitboards[p]
    end

    # Knight move offsets
    deltas = [-17, -15, -10, -6, 6, 10, 15, 17]

    for sq in 0:63
        if !testbit(knights, sq)
            continue
        end

        f, r = file_rank(sq)

        for d in deltas
            to_sq = sq + d
            if !on_board(to_sq)
                continue
            end

            tf, tr = file_rank(to_sq)
            df = abs(tf - f)
            dr = abs(tr - r)

            # Only keep valid knight moves
            if (df == 2 && dr == 1) || (df == 1 && dr == 2)
                # Skip squares occupied by friendly pieces
                if testbit(occupied_friendly, to_sq)
                    continue
                end

                # Check for capture
                capture = 0
                for p in enemy_pieces
                    if testbit(board.bitboards[p], to_sq)
                        capture = p
                        break
                    end
                end

                push!(moves, Move(sq, to_sq; capture = capture))
            end
        end
    end

    return length(moves) - len_before
end

"""
Generate pseudo-legal pawn moves in-place
- `board`: Board struct
- `moves`: preallocated buffer to append moves
Returns: number of moves added
"""
function generate_pawn_moves!(board::Board, moves::Vector{Move})
    len_before = length(moves)

    if board.side_to_move == WHITE
        pawns = board.bitboards[W_PAWN]
        start_rank = 2
        promotion_rank = 7
        direction = 8
        enemy_pieces = B_PAWN:B_KING
        enemy_pawn = B_PAWN
        promo_pieces = (W_QUEEN, W_ROOK, W_BISHOP, W_KNIGHT)
    else
        pawns = board.bitboards[B_PAWN]
        start_rank = 7
        promotion_rank = 2
        direction = -8
        enemy_pieces = W_PAWN:W_KING
        enemy_pawn = W_PAWN
        promo_pieces = (B_QUEEN, B_ROOK, B_BISHOP, B_KNIGHT)
    end

    for sq in 0:63
        if !testbit(pawns, sq)
            continue
        end

        file, rank = file_rank(sq)

        # single push
        to_sq = sq + direction
        if on_board(to_sq) && !any(testbit(board.bitboards[p], to_sq) for p in ALL_PIECES)
            if rank == promotion_rank
                # promotion
                for promo in promo_pieces
                    push!(moves, Move(sq, to_sq; promotion = promo))
                end
            else
                push!(moves, Move(sq, to_sq))

                # double push
                if rank == start_rank
                    to_sq2 = sq + 2*direction
                    if !any(testbit(board.bitboards[p], to_sq2) for p in ALL_PIECES)
                        push!(moves, Move(sq, to_sq2))
                    end
                end
            end
        end

        # captures
        for delta in (-1, 1)
            to_sq = sq + delta + direction
            if !on_board(to_sq)
                continue
            end
            to_file, _ = file_rank(to_sq)
            if abs(to_file - file) != 1
                continue  # skip wraparound
            end

            captured = 0
            for p in enemy_pieces
                if testbit(board.bitboards[p], to_sq)
                    captured = p
                    break
                end
            end

            if captured != 0
                if rank == promotion_rank
                    for promo in promo_pieces
                        push!(moves, Move(sq, to_sq; capture = captured, promotion = promo))
                    end
                else
                    push!(moves, Move(sq, to_sq; capture = captured))
                end
            end

            # en-passant
            if to_sq == board.en_passant
                push!(moves, Move(sq, to_sq; capture = enemy_pawn, en_passant = true))
            end
        end
    end

    return length(moves) - len_before
end

"""
Generate pseudo-legal king moves in-place
- `board`: Board struct
- `moves`: preallocated buffer to append moves
Returns: number of moves added
"""
function generate_king_moves!(board::Board, moves::Vector{Move})
    len_before = length(moves)

    if board.side_to_move == WHITE
        kings = board.bitboards[W_KING]
        friendly_pieces = W_PAWN:W_KING
        enemy_pieces = B_PAWN:B_KING
        rights = board.castling_rights
        king_sq = 4   # e1
    else
        kings = board.bitboards[B_KING]
        friendly_pieces = B_PAWN:B_KING
        enemy_pieces = W_PAWN:W_KING
        rights = board.castling_rights
        king_sq = 60  # e8
    end

    # Bitboard of all friendly pieces
    occupied_friendly = zero(UInt64)
    for p in friendly_pieces
        occupied_friendly |= board.bitboards[p]
    end

    # King move offsets (one square in any direction)
    deltas = [-9, -8, -7, -1, 1, 7, 8, 9]

    for sq in 0:63
        if !testbit(kings, sq)
            continue
        end

        f, r = file_rank(sq)

        for d in deltas
            to_sq = sq + d
            if !on_board(to_sq)
                continue
            end

            tf, tr = file_rank(to_sq)
            if abs(tf - f) <= 1 && abs(tr - r) <= 1
                if !testbit(occupied_friendly, to_sq)
                    # capture check
                    capture = 0
                    for p in enemy_pieces
                        if testbit(board.bitboards[p], to_sq)
                            capture = p
                            break
                        end
                    end
                    push!(moves, Move(sq, to_sq; capture = capture))
                end
            end
        end

        # --------------------
        # Castling (pseudo-legal)
        # --------------------
        # White
        if board.side_to_move == WHITE && testbit(kings, 4)
            # kingside
            if (rights & 0b0001) != 0 &&
               !any(testbit(board.bitboards[p], 5) || testbit(board.bitboards[p], 6) for p in ALL_PIECES)
                push!(moves, Move(4, 6; castling = 1))
            end
            # queenside
            if (rights & 0b0010) != 0 &&
               !any(testbit(board.bitboards[p], 1) || testbit(board.bitboards[p], 2) || testbit(board.bitboards[p], 3) for p in ALL_PIECES)
                push!(moves, Move(4, 2; castling = 2))
            end
        # Black
        elseif board.side_to_move == BLACK && testbit(kings, 60)
            # kingside
            if (rights & 0b0100) != 0 &&
               !any(testbit(board.bitboards[p], 61) || testbit(board.bitboards[p], 62) for p in ALL_PIECES)
                push!(moves, Move(60, 62; castling = 1))
            end
            # queenside
            if (rights & 0b1000) != 0 &&
               !any(testbit(board.bitboards[p], 57) || testbit(board.bitboards[p], 58) || testbit(board.bitboards[p], 59) for p in ALL_PIECES)
                push!(moves, Move(60, 58; castling = 2))
            end
        end
    end

    return length(moves) - len_before
end


"""
Generate pseudo-legal sliding piece moves (bishop, rook, queen) in-place
- `board`: Board struct
- `bb_piece`: bitboard of the sliding piece type
- `directions`: vector of direction offsets
- `moves`: preallocated buffer to append moves
- `start_len`: index in `moves` to start appending
Returns: number of moves added
"""
function generate_sliding_moves!(board::Board, bb_piece::UInt64, directions::Vector{Int}, moves::Vector{Move}, start_len::Int)
    len_before = length(moves)

    # Friendly and enemy piece ranges
    if board.side_to_move == WHITE
        friendly_pieces = W_PAWN:W_KING
        enemy_pieces = B_PAWN:B_KING
    else
        friendly_pieces = B_PAWN:B_KING
        enemy_pieces = W_PAWN:W_KING
    end

    # Bitboard of all friendly pieces
    occupied_friendly = zero(UInt64)
    for p in friendly_pieces
        occupied_friendly |= board.bitboards[p]
    end

    for sq in 0:63
        if !testbit(bb_piece, sq)
            continue
        end
        f, r = file_rank(sq)

        for d in directions
            to_sq = sq
            prev_f, prev_r = f, r

            while true
                to_sq += d
                if !on_board(to_sq)
                    break
                end

                tf, tr = file_rank(to_sq)
                if abs(tf - prev_f) > 1 || abs(tr - prev_r) > 1
                    break
                end
                prev_f, prev_r = tf, tr

                # Blocked by friendly piece
                if testbit(occupied_friendly, to_sq)
                    break
                end

                # Capture check
                capture = 0
                for p in enemy_pieces
                    if testbit(board.bitboards[p], to_sq)
                        capture = p
                        break
                    end
                end

                push!(moves, Move(sq, to_sq; capture = capture))

                if capture != 0
                    break
                end
            end
        end
    end

    return length(moves) - len_before
end

"""
Generate pseudo-legal bishop moves in-place
- `board`: Board struct
- `moves`: buffer to append moves
Returns: number of moves added
"""
function generate_bishop_moves!(board::Board, moves::Vector{Move})
    start_len = length(moves)
    bb = board.side_to_move == WHITE ? board.bitboards[W_BISHOP] : board.bitboards[B_BISHOP]
    dirs = [-9, -7, 7, 9]
    return generate_sliding_moves!(board, bb, dirs, moves, start_len)
end

"""
Generate pseudo-legal rook moves in-place
"""
function generate_rook_moves!(board::Board, moves::Vector{Move})
    start_len = length(moves)
    bb = board.side_to_move == WHITE ? board.bitboards[W_ROOK] : board.bitboards[B_ROOK]
    dirs = [-8, -1, 1, 8]
    return generate_sliding_moves!(board, bb, dirs, moves, start_len)
end

"""
Generate pseudo-legal queen moves in-place
"""
function generate_queen_moves!(board::Board, moves::Vector{Move})
    start_len = length(moves)
    bb = board.side_to_move == WHITE ? board.bitboards[W_QUEEN] : board.bitboards[B_QUEEN]
    dirs = [-9, -8, -7, -1, 1, 7, 8, 9]
    return generate_sliding_moves!(board, bb, dirs, moves, start_len)
end


